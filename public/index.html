<!doctype html>
<html lang="it" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <meta name="color-scheme" content="dark light" />
  <title>Assistente di Manuel — Chat</title>
  <style>
    :root{
      --bg:#0b0f1a;--bg-grad-1:#0b0f1a;--bg-grad-2:#121a2f;
      --surface:#0f1629cc;--surface-2:#121a2fcc;--card:#131c37aa;
      --text:#e9eefc;--muted:#aab3cd;--primary:#86a6ff;--accent:#b38bff;
      --ok:#35d39e;--warn:#ffb64d;--border:1px solid rgba(255,255,255,.08);
      --shadow:0 10px 40px rgba(0,0,0,.55);--pad:clamp(12px,2vw,20px)
    }
    :root[data-theme="light"]{
      --bg:#f7f8ff;--bg-grad-1:#f7f8ff;--bg-grad-2:#e9ecff;
      --surface:#ffffffcc;--surface-2:#ffffffee;--card:#ffffffcc;
      --text:#0b0f1a;--muted:#4a5470;--border:1px solid rgba(0,0,0,.08);
      --shadow:0 12px 36px rgba(0,0,0,.10)
    }
    *{box-sizing:border-box} html,body{height:100%;margin:0}
    body{
      font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 10% -10%, #23326b44, transparent),
        radial-gradient(1000px 600px at 100% 0%, #5b3cc744, transparent),
        linear-gradient(160deg, var(--bg-grad-1), var(--bg-grad-2));
      overflow:hidden;
    }
    .wrap{height:100dvh;display:grid;grid-template-rows:auto 1fr auto;}
    .header{position:sticky;top:0;z-index:20;display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px var(--pad);backdrop-filter: blur(10px);background:linear-gradient(180deg, var(--surface), transparent);border-bottom:var(--border)}
    .brand{display:flex;align-items:center;gap:12px}
    .logo{width:32px;height:32px;display:grid;place-items:center;border-radius:10px;background:linear-gradient(135deg,var(--primary),var(--accent));color:#0b0f1a;font-weight:900;box-shadow:var(--shadow)}
    .title{font-weight:700;letter-spacing:.2px}
    .status{display:flex;align-items:center;gap:8px;font-size:.95em;color:var(--muted)}
    .dot{width:10px;height:10px;border-radius:999px;background:var(--warn);box-shadow:0 0 0 2px #0002}
    .chat{max-width:980px;margin:0 auto;padding:16px var(--pad);overflow:auto;scroll-behavior:smooth}
    .msgs{display:flex;flex-direction:column;gap:12px;padding-bottom:24px}
    .msg{max-width:min(780px, 90%);padding:12px 14px;border-radius:18px;line-height:1.45;background:var(--card);backdrop-filter: blur(6px);box-shadow:var(--shadow);border:var(--border);animation:pop .15s ease;white-space:pre-wrap}
    .msg.me{align-self:flex-end;background:linear-gradient(135deg,#20305f,#273a75)}
    .msg.bot{align-self:flex-start;background:linear-gradient(135deg,#121a32,#101527)}
    .msg ol{margin:10px 0;padding-left:24px;white-space:normal}
    .msg li{margin:8px 0;line-height:1.6;list-style-position:outside}
    .msg strong{font-weight:700;color:var(--primary)}
    .msg p{margin:8px 0;white-space:pre-wrap}
    .msg p:first-child{margin-top:0}
    .msg p:last-child{margin-bottom:0}
    .meta{display:flex;gap:8px;align-items:center;color:var(--muted);font-size:.82em;margin-top:6px}
    .composer{position:sticky;bottom:0;z-index:15;padding:12px var(--pad) calc(12px + env(safe-area-inset-bottom));background:linear-gradient(0deg, var(--surface-2), transparent);backdrop-filter: blur(10px);border-top:var(--border)}
    .row{max-width:980px;margin:0 auto;display:flex;gap:10px;align-items:flex-end}
    textarea{flex:1;min-height:48px;max-height:33dvh;resize:none;padding:12px 14px;border-radius:16px;border:var(--border);background:rgba(255,255,255,.03);color:var(--text);outline:none}
    .btn{height:48px;display:inline-flex;align-items:center;gap:10px;padding:0 16px;border-radius:14px;border:none;cursor:pointer;font-weight:700;color:#0b0f1a;background:linear-gradient(135deg,var(--primary),var(--accent));box-shadow:var(--shadow)}
    .btn[disabled]{opacity:.7;cursor:wait}
    @media (max-width:720px){.msg{max-width:92%}}
    @media (prefers-reduced-motion:reduce){*{scroll-behavior:auto}}
  </style>
</head>
<body>
  <div class="wrap">
    <header class="header">
      <div class="brand">
        <div class="logo">M</div>
        <div class="title">Assistente di Manuel</div>
      </div>
      <div class="status" title="Stato server">
        <span class="dot" id="netDot"></span>
        <span id="netText">controllo…</span>
      </div>
    </header>

    <main class="chat" aria-live="polite">
      <div class="msgs" id="messages"></div>
    </main>

    <footer class="composer">
      <div class="row">
        <textarea id="input" placeholder="Scrivi e premi Invio… (Shift+Invio va a capo)" autocomplete="off"></textarea>
        <button id="send" class="btn" type="button">Invia</button>
      </div>
    </footer>
  </div>

  <script>
"use strict";
const el = {
  messages: document.getElementById("messages"),
  input: document.getElementById("input"),
  send: document.getElementById("send"),
  netDot: document.getElementById("netDot"),
  netText: document.getElementById("netText")
};

let threadId = null;
const nowTime = () => new Date().toLocaleTimeString([], { hour:"2-digit", minute:"2-digit" });

// HTML escape per sicurezza
function escapeHtml(s){ 
  return String(s).replace(/[&<>"']/g, m => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[m])); 
}

// Pulizia citazioni/link ma mantiene struttura
function cleanChat(text){
  let s = String(text || "");
  // Rimuovi citazioni tipo 【1】
  s = s.replace(/[【〔][^】〕]*[】〕]/g, "");
  // Rimuovi riferimenti a file tipo [file.pdf]
  s = s.replace(/(?:\s*`?\[(?:\^\w+|\d+(?::[^\]]+)?|[^\]]{1,120}\.(?:pdf|docx?|xlsx?|pptx?|txt|md|png|jpe?g|webp|svg))\]`?)+/gi, "");
  // Converti link markdown in testo
  s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "$1");
  // Rimuovi link angle bracket
  s = s.replace(/<https?:\/\/[^>\s]+>/gi, "");
  // Pulisci spazi multipli
  s = s.replace(/\s{2,}/g, " ");
  return s;
}

// Converti markdown semplice in HTML
function markdownToHtml(text) {
  if (!text) return "";
  
  // Escape HTML prima di processare
  let html = escapeHtml(text);
  
  // Converti bold: **testo** -> <strong>testo</strong>
  html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  
  // Gestisci liste numerate
  const lines = html.split('\n');
  let result = [];
  let inList = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const listMatch = line.match(/^(\s*)(\d+)\.\s+(.+)$/);
    
    if (listMatch) {
      if (!inList) {
        result.push('<ol>');
        inList = true;
      }
      result.push(`<li>${listMatch[3]}</li>`);
    } else {
      if (inList) {
        result.push('</ol>');
        inList = false;
      }
      if (line.trim()) {
        result.push(`<p>${line}</p>`);
      }
    }
  }
  
  if (inList) {
    result.push('</ol>');
  }
  
  return result.join('\n');
}

function getBehavior(){
  return [
    "Parla chiaro e sintetico.",
    "Punto chiave subito, poi dettagli.",
    "Niente link o citazioni in chiaro.",
    "Coerente col ruolo di assistente di Manuel.",
    "Non inventare dati."
  ].join("\n");
}

function introText(){
  return "Ciao! Sono l'assistente di Manuel. Il mio padrone mi ha addestrato per simulare un colloquio di lavoro. Iniziamo? Prometto di dire la verità";
}

// UI - Crea bubble con HTML formattato
function addBubble(role, text){
  const wrap = document.createElement("div");
  wrap.className = `msg ${role==="user"?"me":"bot"}`;
  
  if (role === "user") {
    // User message: solo testo
    wrap.textContent = text;
  } else {
    // Bot message: HTML formattato
    const cleaned = cleanChat(text);
    wrap.innerHTML = markdownToHtml(cleaned);
  }
  
  const meta = document.createElement("div");
  meta.className = "meta";
  meta.textContent = nowTime();
  wrap.appendChild(meta);
  el.messages.appendChild(wrap);
  el.messages.parentElement.scrollTop = el.messages.parentElement.scrollHeight;
  return wrap;
}

function addStreamingBubble(){
  const wrap = document.createElement("div");
  wrap.className = "msg bot";
  const txt = document.createElement("div");
  txt.textContent = "";
  const meta = document.createElement("div");
  meta.className = "meta";
  meta.textContent = "…";
  wrap.appendChild(txt);
  wrap.appendChild(meta);
  el.messages.appendChild(wrap);
  el.messages.parentElement.scrollTop = el.messages.parentElement.scrollHeight;
  return { wrap, txt, meta };
}

// Aggiorna bubble con HTML durante lo streaming
function updateStreamingBubble(bubble, text) {
  const cleaned = cleanChat(text);
  bubble.txt.innerHTML = markdownToHtml(cleaned);
  el.messages.parentElement.scrollTop = el.messages.parentElement.scrollHeight;
}

// parsers: accetta sia JSON line-by-line sia SSE "data: {...}"
function extractTextDelta(evt){
  const e = evt?.event || evt?.type;
  const data = evt?.data || evt;

  // 1) Assistants v2: thread.message.delta -> data.delta.content[].text.value
  if (e === "thread.message.delta" || e === "message.delta") {
    let out = "";
    const parts = data?.delta?.content || [];
    for (const p of parts) {
      if (p?.text?.value) out += p.text.value;
      else if (typeof p?.text === "string") out += p.text;
    }
    return out;
  }

  // 2) Responses API: response.output_text.delta -> data.delta
  if (e === "response.output_text.delta") {
    return data?.delta ?? "";
  }

  return "";
}

async function ping(){
  try{
    const res = await fetch("/.netlify/functions/gptHandler", { method:"OPTIONS" });
    el.netDot.style.background = res.ok ? "var(--ok)" : "var(--warn)";
    el.netText.textContent = res.ok ? "online" : "non raggiungibile";
  }catch{
    el.netDot.style.background = "var(--warn)";
    el.netText.textContent = "non raggiungibile";
  }
}

async function sendMessage(){
  const text = (el.input.value || "").trim();
  if(!text) return;

  addBubble("user", text);
  el.input.value = "";
  el.send.disabled = true;

  const streamUI = addStreamingBubble();

  const payload = {
    message: text,
    threadId,
    behavior: getBehavior(),
    summary: ""
  };

  try{
    const res = await fetch("/.netlify/functions/gptHandler", {
      method: "POST",
      headers: { "Content-Type": "application/json", "Accept": "text/event-stream" },
      body: JSON.stringify(payload)
    });

    el.netDot.style.background = res.ok ? "var(--ok)" : "var(--warn)";
    el.netText.textContent = res.ok ? "online" : `errore ${res.status}`;

    const hdrTid = res.headers.get("x-thread-id");
    if (!threadId && hdrTid) threadId = hdrTid;

    const ctype = (res.headers.get("Content-Type") || "").toLowerCase();

    if (res.ok && res.body && (ctype.includes("event-stream") || ctype.includes("text"))) {
      // STREAM DI EVENTI
      const reader = res.body.getReader();
      const decoder = new TextDecoder();
      let buf = "";
      let full = "";

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buf += decoder.decode(value, { stream: true });

        const lines = buf.split(/\r?\n/);
        buf = lines.pop() || "";

        for (let line of lines) {
          line = line.trim();
          if (!line) continue;
          if (line.startsWith("data:")) line = line.slice(5).trim();
          if (line === "[DONE]") continue;

          try {
            const evt = JSON.parse(line);
            const delta = extractTextDelta(evt);
            if (delta) {
              full += delta;
              updateStreamingBubble(streamUI, full);
            }
          } catch { /* ignora frammenti non JSON */ }
        }
      }
      streamUI.meta.textContent = nowTime();
    } else {
      // FALLBACK non-stream (JSON)
      const data = await res.json().catch(()=>({}));
      const reply = data?.reply || "Nessuna risposta ricevuta.";
      const cleaned = cleanChat(reply);
      streamUI.txt.innerHTML = markdownToHtml(cleaned);
      streamUI.meta.textContent = nowTime();
      if (!threadId && data?.threadId) threadId = data.threadId;
    }
  } catch (err) {
    streamUI.txt.textContent = "Errore di connessione. Riprova tra poco.";
    streamUI.meta.textContent = nowTime();
    el.netDot.style.background = "var(--warn)";
    el.netText.textContent = "non raggiungibile";
    console.error(err);
  } finally {
    el.send.disabled = false;
    el.input.focus();
  }
}

// UX
function autosize(){ 
  el.input.style.height="auto"; 
  const maxPx=Math.round(window.innerHeight*0.33); 
  el.input.style.height=Math.min(el.input.scrollHeight,maxPx)+"px"; 
}

el.send.addEventListener("click", sendMessage);
el.input.addEventListener("keydown", (ev)=>{ 
  if(ev.key==="Enter" && !ev.shiftKey){ 
    ev.preventDefault(); 
    sendMessage(); 
  } 
});
el.input.addEventListener("input", autosize);

// avvio
addBubble("assistant", introText());
autosize();
ping();
setInterval(ping, 15000);
  </script>
</body>
</html>

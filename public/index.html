<script>
"use strict";

/* ====== SEMPRE CONVERSAZIONE NUOVA AD OGNI APERTURA ====== */
/* (non salviamo history/threadId; manteniamo solo il tono UI) */
try {
  localStorage.removeItem("history");
  localStorage.removeItem("threadId");
} catch {}

/* ============ DOM ============ */
const el = {
  messages: document.getElementById("messages"),
  input: document.getElementById("input"),
  send: document.getElementById("send"),
  toneSwitch: document.getElementById("toneSwitch"),
  toneLabel: document.getElementById("toneLabel"),
  netDot: document.getElementById("netDot"),
  netText: document.getElementById("netText"),
  toast: document.getElementById("toast"),
};

/* ============ STATE ============ */
let threadId = null;                                  // solo in RAM (sessione corrente)
let tone = localStorage.getItem("tone") || "informale"; // persistiamo solo il tono

/* ============ UTILS ============ */
const nowTime = () => new Date().toLocaleTimeString([], { hour:"2-digit", minute:"2-digit" });
const showToast = (t) => { if(!el.toast) return; el.toast.textContent=t; el.toast.classList.add("show"); setTimeout(()=>el.toast.classList.remove("show"), 2000); };

/* anti-XSS basico prima del render */
function escapeHtml(s) {
  return String(s)
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;");
}

/* ============ SANITIZE TESTO ASSISTENTE ============
   - rimuove citazioni [1], [1][2], [6:qualcosa], note [^1]
   - rimuove backtick (inline/blocks)
   - trasforma [testo](url) -> testo
*/
function sanitize(text) {
  let s = String(text);

  // blocchi citazioni e note
  s = s.replace(/(\s*`?\[\d+(?::[^\]]+)?\]`?)+/g, ""); // [1][2], [6:cv.pdf], ecc.
  s = s.replace(/\s*\[\^[^\]]+\]/g, "");               // [^1], [^note]

  // markdown link -> solo testo visibile
  s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "$1");

  // rimuovi backtick
  s = s.replace(/`{1,3}([^`]+)`{1,3}/g, "$1");

  // parentesi/brackets vuoti + spazi doppi
  s = s.replace(/\s*[\(\[\{]\s*[\)\]\}]\s*/g, "");
  s = s.replace(/\s{2,}/g, " ").replace(/\s+([,.;:!?])/g, "$1").trim();

  return s;
}

/* ============ TONE INIT ============ */
(function initTone(){
  el.toneSwitch.checked = (tone === "formale");
  el.toneLabel.textContent = tone === "formale" ? "Formale" : "Informale";
})();

/* ============ BEHAVIOR (istruzioni runtime) ============ */
function getBehavior(t){
  const hard = [
    "Parla chiaro e sintetico.",
    "Punto chiave subito, poi dettagli.",
    "Coerente col ruolo di assistente di Manuel.",
    "Non inventare dati.",
    "Se domanda vaga → chiedi specifica."
  ].join("\n");
  return t === "formale"
    ? `Sei l’assistente professionale di Manuel per un pre-colloquio. Tono formale (Lei). ${hard}`
    : `Sei l’assistente professionale di Manuel per un pre-colloquio. Tono informale (tu). ${hard}`;
}

/* ============ INTRO ============ */
function introByTone(t){
  return t === "formale"
    ? "Buongiorno, sono l’assistente professionale di Manuel: lo sostituisco virtualmente per un pre-colloquio. Mi dica pure."
    : "Ciao, sono l’assistente professionale di Manuel: lo sostituisco virtualmente per un pre-colloquio. Dimmi pure.";
}

/* ============ UI MESSAGGI ============ */
function addBubble(role, text){
  const wrap = document.createElement("div");
  wrap.className = `msg ${role === "user" ? "me" : "bot"}`;

  // le risposte dell’assistente passano dal sanitize
  const safe = role === "assistant" ? sanitize(text) : String(text);

  wrap.innerHTML = escapeHtml(safe).replace(/\n/g,"<br>");
  const meta = document.createElement("div");
  meta.className = "meta";
  meta.textContent = nowTime();
  wrap.appendChild(meta);
  el.messages.appendChild(wrap);
  el.messages.parentElement.scrollTop = el.messages.parentElement.scrollHeight;
}
function addThinking(){
  const wrap = document.createElement("div");
  wrap.className = "msg bot";
  const dots = document.createElement("div");
  dots.className = "typing";
  dots.innerHTML = "<i></i><i></i><i></i>";
  wrap.appendChild(dots);
  el.messages.appendChild(wrap);
  el.messages.parentElement.scrollTop = el.messages.parentElement.scrollHeight;
  return wrap;
}

/* ============ INPUT AUTOSIZE ============ */
function autosize(){
  el.input.style.height = "auto";
  const maxPx = Math.round(window.innerHeight * 0.33);
  el.input.style.height = Math.min(el.input.scrollHeight, maxPx) + "px";
}

/* ============ PING SERVER ============ */
async function ping(){
  try{
    const res = await fetch("/.netlify/functions/gptHandler", { method:"OPTIONS" });
    const ok = res.ok;
    el.netDot.style.background = ok ? "var(--ok)" : "var(--warn)";
    el.netText.textContent = ok ? "online" : "non raggiungibile";
  }catch{
    el.netDot.style.background = "var(--warn)";
    el.netText.textContent = "non raggiungibile";
  }
}

/* ============ SEND ============ */
async function sendMessage(){
  const text = (el.input.value || "").trim();
  if(!text) return;

  addBubble("user", text);
  el.input.value = "";
  autosize();
  el.send.disabled = true;
  const thinking = addThinking();

  try{
    const res = await fetch("/.netlify/functions/gptHandler", {
      method: "POST",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify({
        message: text,
        threadId,                 // null alla prima → il server crea il thread
        behavior: getBehavior(tone),
        tone,
        summary: ""               // nessuna memoria persistente
      })
    });

    el.netDot.style.background = res.ok ? "var(--ok)" : "var(--warn)";
    el.netText.textContent = res.ok ? "online" : `errore ${res.status}`;

    const data = await res.json();
    thinking.remove();

    if (!threadId && data?.threadId) {
      // usiamo il thread solo in RAM finché la pagina resta aperta
      threadId = data.threadId;
    }

    const reply = data?.reply || "Nessuna risposta ricevuta.";
    addBubble("assistant", reply);

  }catch(err){
    thinking.remove();
    addBubble("assistant", "Errore di connessione. Riprova tra poco.");
    el.netDot.style.background = "var(--warn)";
    el.netText.textContent = "non raggiungibile";
    console.error(err);
  }finally{
    el.send.disabled = false;
    el.input.focus();
  }
}

/* ============ EVENTS ============ */
el.send.addEventListener("click", sendMessage);
el.input.addEventListener("keydown", (ev)=>{
  if(ev.key === "Enter" && !ev.shiftKey){
    ev.preventDefault();
    sendMessage();
  }
});
el.input.addEventListener("input", autosize);

el.toneSwitch.addEventListener("change", ()=>{
  tone = el.toneSwitch.checked ? "formale" : "informale";
  el.toneLabel.textContent = el.toneSwitch.checked ? "Formale" : "Informale";
  localStorage.setItem("tone", tone); // persistiamo SOLO il tono
  showToast(`Tono: ${tone}`);
});

/* ============ BOOTSTRAP ============ */
addBubble("assistant", introByTone(tone));
autosize();
ping();
setInterval(ping, 15000);
</script>
